package com.oop.examples;

public enum ClassTypes {
    LOCAL("ЛОКАЛЬНЫЙ класс.\n" +
            "        1. Объявляется в рамках одного метода.\n" +
            "        2. Не может быть статическим.\n" +
            "        3. Может быть абстрактным.\n" +
            "        4. Объект локального класса не может создаваться за пределами метода или блока, в котором его объявили.\n" +
            "        5. В локальных классах нельзя объявлять статические инициализаторы (блоки инициализации) или интерфейсы.\n" +
            "           Но у локальных классов могут быть статические члены при условии, что они постоянные переменные(static final).\n" +
            "\n" +
            "        ПРИМЕНЕНИЕ:\n" +
            "        - для обработки сложно-структурированных данных(коллекции, массивы, CSV-файлы, таблицы БД...),\n" +
            "        приходящих в метод.\n" +
            "         - для улучшения читабельности кода, его масштабируемости и для обработки данных в максимально понятном виде.\n" +
            "        !!! ПРИМЕЧАНИЕ: ПО ВОЗМОЖНОСТИ НЕ ДОПУСКАТЬ НЕОБХОДИМОСТИ СОЗДАНИЯ ЛОКАЛЬНЫХ КЛАССОВ !!!"),
    ANONYMOUS("АНОМИМНЫЙ класс.\n" +
            "       0. Создаётся один раз в момент инициализации объекта.\n" +
            "       1. Не имеет имени.\n" +
            "       2. Не имеет явного конструктора(можно вызвать конструктор суперкласса!).\n" +
            "       3. Не доступен классам извне,за исключением\n" +
            "           неявного обращения посредством объектной ссылки\n" +
            "           на суперкласс или интерфейс.\n" +
            "       4. НИКОГДА не могут быть СТАТИЧЕСКИМИ или АБСТРАКТНЫМИ.\n" +
            "       5. Не может содержать статические переменные и методы.\n" +
            "       6. В конце ставится  ;  [точка с запятой].\n" +
            "          Одновременно объявляется класс (посредством фигурных скобок) и\n" +
            "          создаётся его объект с помощью   ();\n" +
            "       7. Каждый анонимный класс объявляется внутри выражения.\n" +
            "       8. Имеет доступ КО ВСЕМ ПОЛЯМ ВНЕШНЕГО КЛАССА (ДАЖЕ PRIVATE !!!!!)\n" +
            "       9. Может реализовывать только один интерфейс либо наследовать один класс.\n" +
            "\n" +
            "        ПРИМЕНЕНИЕ:\n" +
            "        - для описания специфической(особенной) реализции известного ранее поведения(интерфейс, класс).\n" +
            "         Есть известное ранее поведение(например SimpleInterface()). Требуется описать его\n" +
            "         специфичную реализацию, обрабатывающую данные, котрорые передать в SimpleInterface() невозможно, при\n" +
            "         штатном его использовании. Например, необходимы данные из массива String[] args метода main().\n" +
            "         В обычном режиме передать их в SimpleInterface() невозможно(метод print() не принимает никаких параметров)."),
    LAMBDA("ЛЯМБДА-ВЫРАЖЕНИЕ.\n" +
            "        1. Лямбда-выражение является блоком кода с параметрами.\n" +
            "        2. Используйте лямбда-выражение, когда хотите выполнить блок кода в более поздний момент времени.\n" +
            "        3. Лямбда-выражения могут быть преобразованы в функциональные интерфейсы.\n" +
            "        4. Лямбда-выражения имеют доступ к final переменным из охватывающей области видимости.\n" +
            "        5. Ссылки на метод и конструктор ссылаются на методы или конструкторы без их вызова.\n" +
            "        6. Можно добавить методы по умолчанию и статические методы к интерфейсам, " +
            "   которые обеспечивают конкретные реализации.\n" +
            "        7. Вы должны разрешать любые конфликты между методами по умолчанию из нескольких интерфейсов.\n" +
            "\n" +
            "        ПРИМЕНЕНИЕ:\n" +
            "        Основная цель лямбда-выражений – повысить читабельность и уменьшить количество кода."),
    ABSTRACT("АБСТРАКТНЫЙ класс.\n" +
            "        1. Содержит методы без реализации.\n" +
            "        2. Создается с целью создания общего интерфейса между разными реализациями классов,\n" +
            "           которые будут производными от абстрактного класса\n" +
            "        3. Абстрактный класс создается для определения некоторых общих черт производных от него классов,\n" +
            "           которые определяют конкретную его реализацию.\n" +
            "        4. Класс считается абстрактным, если в классе объявлен хотя бы один абстрактный метод.\n" +
            "           Перед объявлением абстрактного класса размещается ключевое слово abstract.\n" +
            "        5. НЕЛЬЗЯ СОЗДАТЬ ЭКЗЕМПЛЯР Абстрактного класса.\n" +
            "        6. В нём можно определить поля и методы.\n"
            +
            "\n" +
            "        ПРИМЕНЕНИЕ:\n" +
            "        Абстрактные классы призваны предоставлять базовый функционал для классов-наследников.\n" +
            "        А производные классы уже реализуют этот функционал."),
    CLASS(getDefaultDescription()),
    INNER("ВНУТРЕННИЙ класс(inner или non static nested classes).\n" +
            "        1. Внутренний класс ведет себя как обычный класс за тем исключением,\n" +
            "           что его объекты могут быть созданы только внутри внешнего класса.\n" +
            "        2. Имеет доступ ко всем полям (даже PRIVATE) внешнего класса и наоборот.\n" +
            "        3. Ссылку на объект внешнего класса из внутреннего класса\n" +
            "           можно получить с помощью выражения Внешний_класс.this\n" +
            "        4. Объекты внутренних классов могут быть созданы только в том классе,\n" +
            "           в котором внутренние классы опеределены.\n" +
            "        5. Их можно объявить внутри любого контекста, в том числе внутри метода и даже в цикле\n" +
            "        6. Из объекта вложенного класса нельзя обращаться к нестатическим членам внешнего класса.\n" +
            "        7. Для создания объекта статического внутреннего класса не нужен объект внешнего классаю.\n" +
            "\n" +
            "        ПРИМЕНЕНИЕ:\n" +
            "          Если связь между объектом внутреннего класса и объектом внешнего класса не нужна,\n" +
            "          можно сделать внутренний класс статическим static."),
    NESTED(getDefaultDescription());

    private final String description;

    ClassTypes(String description) {
        this.description = description;
    }

    public String getDescription() {
        return "\nClass type description:\n'" + description + "'";
    }

    private static String getDefaultDescription() {
        return "no description!";
    }
}
